Understanding the Istio architecture    First, let's meet the main components of Istio and understand what they do and how they relate to each other.    Istio is a large framework that provides a lot of capabilities, and it has multiple parts that interact with each other and with Kubernetes components (mostly indirectly and unobtrusively). It is divided into a control plane and a data plane. The data plane is a set of proxies (one per pod). Their control plane is a set of components that are responsible for configuring the proxies and collecting telemetry data.    The following diagram illustrates the different parts of Istio, how they are related to each other, and what information is exchanged between them:        Figure 14.5: Istio architecture    Let's go a little deeper into each component, starting with the Envoy proxy.    Envoy    We discussed Envoy briefly when we reviewed service meshes for Kubernetes. Here, it serves as the data plane of Istio. Envoy is implemented in C++ and is a high-performance proxy. For each pod in the service mesh, Istio injects (either automatically or through the istioctl CLI) an Envoy side container that does all the heavy lifting, such as:          Proxy HTTP, HTTP/2, and gRPC traffic between pods      Sophisticated load balancing      mTLS termination      HTTP/2 and gRPC proxies      Providing service health      Circuit breaking for unhealthy services      Percent-based traffic shaping      Injecting faults for testing      Detailed metrics        The Envoy proxy controls all the incoming and outgoing communication to its pod. It is, by far, the most important component of Istio. The configuration of Envoy is not trivial, and this is a large part of what the Istio control plane deals with.    The next component is Pilot.    Pilot    Pilot is responsible for platform-agnostic service discovery, dynamic load balancing, and routing. It translates high-level routing rules into an Envoy configuration. This abstraction layer allows Istio to run on multiple orchestration platforms. Pilot takes all the platform-specific information, converts it into the Envoy data plane configuration format, and propagates it to each Envoy proxy with the Envoy data plane API. Pilot is stateless; in Kubernetes, all the configuration is stored as custom resources definitions (CRDs) in etcd.    Let's move on to Mixer.    Mixer    Mixer is responsible for abstracting the metrics collection, policies, and auditing. These aspects are typically implemented in services by accessing APIs directly for specific backends. This has the benefit of offloading this burden from service developers and putting the control into the hands of the operators that configure Istio. It also enables switching backends easily without code changes. Here are some the backend types that Mixer can work with:          Logging      Authorization      Quota      Telemetry      Billing        The interaction between the Envoy proxy and Mixer is straightforward â€“ before each request, the proxy calls Mixer for precondition checks, which might cause the request to be rejected. After each request, the proxy reports the metrics to Mixer. Mixer has an adapter API to facilitate extensions for arbitrary infrastructure backends. It is a major part of its design.    The next component is Citadel.    Citadel    Citadel is responsible for certificate and key management. It is a key part of Istio security. Citadel integrates with various platforms and aligns with their identity mechanisms. For example, in Kubernetes, it uses service accounts; on AWS, it uses AWS IAM; and on GCP/GKE, it can use GCP IAM. The Istio PKI is based on Citadel. It uses X.509 certificates in SPIFEE format as a vehicle for service identity.    Here is the workflow in Kubernetes:           Citadel creates certificates and key pairs for existing service accounts.       Citadel watches the Kubernetes API server for new service accounts to provision with a certificate a key pair.       Citadel stores the certificates and keys as Kubernetes secrets.       Kubernetes mounts the secrets into each new pod that is associated with the service account (this is standard Kubernetes practice).       Citadel automatically rotates the Kubernetes secrets when the certificates expire.       Pilot generates secure naming information that associates a service account with an Istio service. Pilot then passes the secure naming information to the Envoy proxy.        The final major component that we will cover is Galley.    Galley    Galley is responsible for abstracting the user configuration on different platforms. It provides the ingested configuration to Pilot and Mixer. It is a pretty simple component.    Now that we have broken down Istio into its major components, let's get ready to install Istio into a Kubernetes cluster.
